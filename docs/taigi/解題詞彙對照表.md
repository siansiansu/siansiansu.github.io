# 演算法來用台語講 - 解題詞彙對照表

予你會當用台語來解釋電腦的演算法。

hōo lí ē-tàng iōng Tâi-gí lâi kái-sueh tiān-náu ê ián-sǹg-huat.

:::success
《演算法來用台語講》內底包含誠濟台語新詞的創作，目的是鼓勵咱去揣看覓敢有較適合 ê 詞，來解說予電腦走 ê 演算法。你若有發現寫毋著 ê 所在，請佇下跤留話抑是寫電子批共我講，我會趁有閒的時陣來改，請手梳攑懸，多謝！

🚀 這个網站使用 ê HackMD 平台，是一个會當予逐家做伙參與來寫 ê 網站，你若有興趣做伙合作，也請佇下跤留話抑是寫電子批共我講。

✉️ 電子批: minsiansu@gmail.com
:::

| 英語 | 台語 Tâi-gí | 台灣華語 | 中国翻译 | 解釋  |
|-|-|-|-|-|
| 1D Dynamic Programming | 一次元動態計算 tsi̍t tshù-guân tōng-thài-kè-soàn | 1 維動態規劃 | 一维动态规划 | 使用一維陣列來解決需要考慮一個變數的最佳化問題，通過將問題拆解成子問題並記錄中間結果來提高效率。  |
| 2D Dynamic Programming | 二次元動態計算 jī tshù-guân tōng-thài-kè-soàn | 2 維動態規劃 | 二维动态规划 | 使用二維陣列來解決需要考慮兩個變數的最佳化問題，通過將問題拆解成子問題並記錄中間結果來提高效率。  |
| Algorithm | 演算法/計算術 ián-sǹg-huat/kè-soàn-su̍t | 演算法 | 算法 | 用來解決問題或完成任務的方法。  |
| All pairs shortest path | 凊彩兩點之間的上短路程 tshìn-tshái nňg-tiám tsi-kan ê siōng té lōo-tîng | 任兩點之間的最短路徑 | 任两点之间的最短路径 | 在加權圖中，計算每對節點之間的最短路徑。  |
| Array | 陣列 tīn-lia̍t | 陣列 | 数组 | 陣列是一種資料結構，用來儲存具有相同型別的多個元素，這些元素在記憶體中是連續排列的，可以透過索引快速存取每個元素。  |
| Array transformation | 陣列轉換 tīn-lia̍t tsuán-uānn | 陣列轉換 | 数组转换 | 在一個連接首尾形成環狀結構的數組中進行操作或處理，如循環索引或資料迴圈。  |
| Auxiliary data structures | 輔助資料結構 hú-tsōo-tsu-liāu-kiat-kòo | 輔助資料結構 | 辅助数据结构 | 使用額外的資料結構解決問題。  |
| Backtracking | bak-kuh 演算法 bak-kuh-ián-sǹg-huat | 回溯法 | 回溯法 | Brute-force 的一種，透過不斷嘗試，如果遇到不符合條件就回溯到之前的選擇，來逐步找到解決問題的所有可能解答。  |
| Balance problems | 平衡問題 pîng-hîng-būn-tê | 平衡問題 | 平衡问题 | 在資料結構中，保持各元素或資源間分佈均勻。例如找出分割點使兩邊和相等  |
| Bellman-Ford algorithm | 貝爾曼-福特演算法 Puè-ní-bān Hok-ti̍k ián-sǹg-huat | 貝爾曼-福特演算法 | 贝尔曼-福特算法 | 一種用於計算從單一起點到其他所有點的最短路徑的演算法，且能處理帶有負權重邊的圖。  |
| BFS with queue | 使用排陣做成闊度代先搜揣 sú-iōng pâi-tīn tsò-tsiânn khuah-tōo-tāi-sing-tshiau-tshuē | 使用佇列實現廣度優先搜尋 | 使用队列实现广度优先搜索 | 使用佇列實現廣度優先搜尋。  |
| Bi-connected components | 雙連結元件 siang-liân-kiat-guân-kiānn | 雙連通元件 | 双连通分量 | 在無向圖中，每個元件中的任意兩個節點在去除圖中的任何一條邊後仍能保持連通的最大節點集合。  |
| Bidirectional breadth-first search | 雙爿闊度代先搜揣 siang-pîng-khuah-tōo-tāi-sing-tshiau-tshuē | 雙向廣度優先搜尋 | 双向广度优先搜索 | 雙向廣度優先搜尋是一種圖搜尋演算法，從起點和終點同時進行廣度優先搜尋，當兩邊搜尋相遇時，即找到最短路徑，這樣可以有效減少搜尋空間和時間。  |
| Binary lifting | 增倍法 tsing-puē-huat | 倍增 | 倍增 | 在樹狀結構上進行快速查詢與計算的演算法，特別適用於 LCA 等問題的解決方法。  |
| Binary search | 破爿搜揣演算法 phuà-pîng tshiau-tshuē ián-sǹg-huat | 二元搜尋演算法 | 二分查找算法 | 一種有效率的搜尋演算法，能在有序陣列或資料集中快速尋找目標值的方法。  |
| Binary search tree (BST) | 雙爿搜揣樹 siang-pîng-tshiau-tshuē-tshiū | 二元搜尋樹 | 二叉查找树 | 一種樹狀結構，其中每個節點最多有兩個子節點，並且滿足左子節點的值小於父節點的值，而右子節點的值大於父節點的值。這種結構使得在樹中查找、插入和刪除節點都能夠以較高的效率完成。  |
| Binary tree | 雙爿樹 siang-pîng-tshiū | 二元樹 | 二叉树 | 一種樹狀資料結構，其中每個節點最多有兩個子節點，用於組織資料以及進行有效的搜尋和排序。  |
| Bit manipulation | 位元計算 uī-guân-kè-sǹg | 位元運算 | 位元运算 | 利用二進位資料的運算來有效的處理和操作數字。  |
| Boundary walking | 邊頭行徙 pinn-thâu-kiânn-suá | 邊界行走 | 边界行走 | 在資料結構或圖形處理中，用來沿著特定區域或物件的邊界進行走訪的方法。  |
| Boyer-Moore voting algorithm | 投票演算法 tâu-phiò ián-sǹg-huat/摩爾投票演算法 môo-ní-tâu-phiò ián-sǹg-huat | 多數投票演算法/摩爾投票演算法 | 多数投票算法/摩尔投票算法 | 在線性時間內找出陣列中主要元素的方法。  |
| Branch and bound algorithm (BB) | 分叉隔界演算法 hun-tshe-keh-kài ián-sǹg-huat | 分支定界演算法 | 分支定界算法 | 在解決最佳化或搜索問題時，透過分支、搜索和剪枝來有效地尋找最佳解或全域最優解的演算法。  |
| Breadth-first search | 闊度代先搜揣演算法 khuah-tōo tāi-sing tshiau-tshuē ián-sǹg-huat | 廣度優先搜尋 | 广度优先搜索 | 從起始節點開始逐層擴展探索，確保先探索所有相鄰節點，適合用於尋找最短路徑或狀態空間的解決方案。  |
| Brute-force (BF) | 拚勢演算法 piànn-sè ián-sǹg-huat | 暴力演算法 | 暴力法 | 透過走訪所有的情況，尋找最佳解，通常是在面試時難以立即想出最佳解時提出的解法。根據與面試官的討論，有可能會衍生出其他更適合的解決方案。  |
| Bubble sort | 起波排序 khí-pho-pâi-sī | 冒泡排序 | 冒泡排序 | 一種簡單的排序演算法，通過重複比較相鄰元素並交換它們的位置，將較大的元素「冒泡」到陣列的末尾。  |
| Bucket sort | 桶仔排序 tháng-á-pâi-sī | 桶排序 | 桶排序 | 一種將資料分配到不同桶中進行排序的演算法，然後再將桶中的資料合併以完成整體排序。  |
| Cellular automata | 細胞自動機 sè-pau-tsū-tōng-ki | 細胞自動機 | 细胞自动机 | 一種數學模型，通過在格狀空間中對每個單元格進行局部規則更新來模擬複雜系統的演化。  |
| Chessboard problems | 棋盤問題 kî-puânn būn-tê | 棋盤問題 | 棋盘问题 | 在棋盤上進行特定操作或解決問題，例如放置棋子、尋找路徑或解決擺放問題。  |
| Circular array problems | 圓箍陣列問題 înn-khoo tīn-lia̍t būn-tê | 環型陣列問題 | 环型数组问题 | 在一個環狀結構的陣列中進行操作或解決問題，例如處理循環查詢或走訪。  |
| Combination problems | 組合問題 tsoo-ha̍p būn-tê | 組合問題 | 组合问题 | 在給定的元素集合中，找出所有可能的子集或排列組合的方法。  |
| Complete Binary Tree (CBT) | 完全雙爿樹 uân-tsuân siang-pîng-tshiū | 完全二元樹 | 完全二叉树 | 一種二元樹，每一層都被完全填滿，除了最後一層外，其餘節點都靠左對齊。  |
| Connected components | 連結元件 liân-kiat-guân-kiānn | 連通元件 | 连通分量 | 在無向圖中，任意兩個節點在同一個元件內都可以互相到達的最大節點集合。  |
| Connected graph | 連結圖 liân-kiat-tôo | 連通圖 | 连通图 | 在無向圖中，任意兩個節點之間都可以通過一條或多條邊互相到達。  |
| Counting sort | 計數排序 kè-sòo-pâi-sī | 計數排序 | 计数排序 | 一種非比較排序演算法，通過統計每個元素的出現次數來確定元素的最終位置，並按計數結果進行排序。  |
| Cumulative product | 累積乘積 luí-tsik-sîng-tsik | 累積乘積 | 累积乘积 | 在一個數列中每個元素與其之前所有元素相乘所得到的連續乘積。  |
| Cumulative sum calculation | 累積和計算 luí-tsik-hô-kè-sǹg | 累積和計算 | 累积和计算 | 計算並儲存從開始到每個位置的累積和。  |
| Cycle detection | 循環檢查 sûn-khuân kiám-tsa | 環檢測 | 环检测 | 環檢測是用來識別資料結構（如圖或鏈結串列）中是否存在迴圈或循環的演算法。  |
| Cyclic replacements | 循環替換 sûn-khuân-thè-uānn | 循環替換 | 循环替换 | 在一個序列中，按照特定規則或循環模式進行元素位置互換的操作。  |
| Data structure | 資料結構 tsu-liāu-kiat-kòo | 資料結構 | 数据结构 | 資料結構是一種組織和儲存資料的方式，以便於有效率的存取和修改。  |
| Define pointer roles | 定義指標的角色 tīng-gī tsí-piau ê kak-sik | 定義指標角色 | 定义指针角色 | 定義指標的用途或行為，例如一個用於讀取，一個用於寫入。  |
| Depth-first search | 深度代先搜揣演算法 tshim-tōo tāi-sing tshiau-tshuē ián-sǹg-huat | 深度優先搜尋演算法 | 深度优先搜索算法 | 一種圖或樹的搜尋演算法，優先從起始節點深入到最深的分支，再回溯至上一節點繼續搜尋未探索的路徑。  |
| Difference calculation | 精差計算 tsing-tsha-kè-sǹg | 差值計算 | 差值计算 | 找出兩個數值或集合之間的差。  |
| Dijkstra's algorithm | 戴克斯特拉演算法 tài-khik-su-ti̍k-lá ián-sǹg-huat | 戴克斯特拉演算法 | 戴克斯特拉算法 | 計算從單一起點到圖中所有其他點的最短路徑，前提是圖中邊的權重皆為非負數。  |
| Directed acyclic graph (DAG) | 有向無環圖 ū-hiòng-bô-huân-tôo | 有向無環圖 | 有向无环图 | 一種有向圖，其中不存在任何循環，且邊的方向從不形成迴路。  |
| Directed graph | 有向圖 ū-hiòng-tôo | 有向圖 | 有向图 | 有向圖問題（Directed Graph Problems）是指在有向圖中處理節點和邊的各種問題，如尋找最短路徑、拓撲排序或循環檢測。  |
| Direction arrays | 方向陣列 hong-hiòng-tīn-lia̍t | 方向陣列 | 方向数组 | 使用預定義的方向陣列來簡化走訪和鄰居檢查，例如 directions = \[\[0, 1\], \[0, -1\], \[1, 0\], \[-1, 0\]\]。  |
| Divide and conquer | 分開解決法 hun-khui-kái-kuat-huat | 各個擊破法 | 分治法 | 將題目分成一樣的小題目，最後將結果合併起來，經常應用在其他的演算法中。  |
| Doubly linked list | 雙爿鍊仔列 siang-pîng-liān-á-lia̍t | 雙向鏈結串列 | 双向链表 | 鏈結串列的一種，每個節點包含指向前後兩個節點的指標，使得走訪可以在兩個方向進行。  |
| Dynamic programming (DP) | 動態計算 tōng-thài-kè-soàn | 動態規劃 | 动态规划 | 一種通過將問題拆分為較小子問題，並保存它們的解以避免重複計算的方法。  |
| Edge case handling | 邊界情況處理 pian-kài-tsîng-hóng-tshú-lí | 邊界情況處理 | 边界情况处理 | 注意處理矩陣的邊界和角落元素。  |
| Enumerate | 列舉 lia̍t-kí | 列舉 | 枚举 | 逐一列舉或走訪所有可能的選項或元素。  |
| Eulerian path | 尤拉路徑 iû-la lōo-kìng | 尤拉路徑 | 欧拉路径 | 在圖中找到一條經過每條邊恰好一次的路徑。  |
| Exponential search | 指數搜揣 tsí-sòo-tshiau-tshuē | 指數搜尋 | 指数搜索 | 在有序陣列中查找目標值的演算法，通過指數增長的方式逐步擴展搜尋範圍，直到找到目標值或確定目標值不在陣列中。  |
| Fast and slow pointers | 慢緊指標 bān-kín-tsí-piau | 快慢指標 | 快慢指针 | 在資料結構中使用兩個指針，其中一個以較快的速度移動，另一個以較慢的速度移動，以便檢測循環或找到特定位置。  |
| Fenwick tree/binary indexed tree (BIT) | 芬威克樹 hun-ui-khik-tshiū/雙爿索引樹 siang-pîng-soh-ín-tshiū/樹形陣列 tshiū-hîng-tīn-lia̍t | 芬威克樹/二元索引樹/樹狀陣列 | 芬威克树/二元索引树/树状数组 | 用於頻繁地進行陣列區間求和和單點更新操作。使用樹狀結構來壓縮資訊，能夠在  O(logN) 的時間複雜度內完成這些操作，適合用在頻繁查詢和更新的情況下。  |
| Fibonacci search | 費波那契搜揣 huì-pho-ná-khì tshiau-tshuē | 費波那契搜尋 | 斐波那契搜索 | 一種基於費波那契數列的搜尋演算法，用於在有序陣列中高效率地尋找目標值。  |
| FIFO processing | FIFO 處理 FIFO-tshú-lí | FIFO 處理 | FIFO 処理 | 利用佇列的先進先出特性處理資料。  |
| Floyd–Warshall algorithm | 弗洛伊德演算法 Hu̍t-lo̍k-i-ti̍k ián-sǹg-huat | 弗洛伊德演算法 | 弗洛伊德算法 | 計算圖中每一對節點間的最短路徑，能處理帶有負權重邊的圖。  |
| Formula application | 公式應用 kong-sik-ìng-iōng | 公式應用 | 公式应用 | 應用適當的數學公式解決問題。  |
| Full Binary Tree (FBT) | 滿雙爿樹 muá siang-pîng-tshiū | 滿二元樹 | 满二叉树 | 一種二元樹，每個節點要麼有兩個子節點，要麼沒有子節點，且所有葉子節點都在同一層次。  |
| Graph | 圖 tôo | 圖 | 图 | 通常涉及圖形結構的問題，例如最短路徑、連通性、拓撲排序等，要求對圖的節點和邊進行操作和分析。  |
| Graph and matrix search problems | 圖佮矩陣搜揣問題 tôo kah kí-tīn tshiau-tshuē būn-tê | 圖形與矩陣搜尋問題 | 图形与矩阵搜索问题 | 在圖形結構或矩陣中進行尋找特定元素、路徑或模式的問題。  |
| Greedy algorithm | 痟貪演算法 siáu-tham-ián-sǹg-huat | 貪婪演算法 | 贪心算法 | 透過在每一步選擇當前最佳的選項來試圖達到全局最佳解。  |
| Greedy with priority queue | 痟貪演算法加代先排陣 siáu-tham-ián-sǹg-huat ka tāi-sing-pâi-tīn | 貪婪演算法結合優先佇列 | 贪心算法结合优先队列 | 貪婪演算法搭配優先佇列（Priority Queue）可以有效管理和選擇當前最重要的元素，以達成最佳解。  |
| Hamiltonian path | 漢彌爾頓路徑 hàn-mí-nī-tùn lōo-kìng | 漢彌爾頓路徑 | 哈密顿路径 | 在圖中找到一條經過每個節點恰好一次的路徑。  |
| HashMap | 插濫表 tshap-lām-pió | 雜湊表 | 哈希表 | 用於儲存鍵值對並提供快速的查詢、插入和刪除操作。  |
| HashMap for frequency | 用插濫表算頻率 iōng tshap-lām-pió sǹg pîn-lu̍t | 使用雜湊表統計頻率 | 使用哈希表统计频率 | 記錄前置和出現的次數，用於快速查找。  |
| HashSet | 插濫集合 tshap-lām-tsi̍p-ha̍p | 雜湊集合 | 哈希集 | 用於儲存唯一元素並提供快速的查詢、插入和刪除操作。  |
| Heap sort | 堆積排序 tui-tsik-pâi-sī | 堆積排序 | 堆排序 | 一種基於堆積資料結構的排序演算法，通過構建最大堆積或最小堆積來逐步提取最大或最小元素，實現陣列的排序。  |
| Hungarian algorithm | 匈牙利演算法 Hiong-gâ-lī ián-sǹg-huat | 匈牙利演算法 | 匈牙利算法 | 用於解決二分圖中的最大比對問題，尋找最佳的配對以最大化總權重。  |
| Identify pointer movement | 決定指標 ê 方向 kuat-tīng tsí-piau ê hong-hiòng | 確定指標移動 | 识别指针移动 | 決定指針如何移動（同向、反向、快慢等）  |
| In-place operations | 原位操作 guân-uī-tshau-tsok | 原地操作 | 就地操作 | 在不使用額外空間的情況下修改資料結構。  |
| Inorder traversal | 中央走訪 tiong-sū-tsáu-hóng | 中序走訪 | 中序遍历 | 一種樹的走訪方式，先走訪左子樹，再訪問節點本身，最後走訪右子樹。  |
| Insertion sort | 安插排序 an-tshah-pâi-sī | 插入排序 | 插入排序 | 一種逐步排序演算法，通過將每個新元素插入到已排序部分的正確位置來完成排序。  |
| Interpolation search | 內插搜揣 lāi-tshah-tshiau-tshuē | 內插搜尋 | 插值搜索 | 一種基於資料分佈進行預測的搜尋演算法，用於在有序數組中高效率地尋找目標值。  |
| Intervals problems | 區間問題 khu-kan-būn-tê | 區間問題 | 间隔问题 | 處理和分析區間的問題，如合併重疊區間、查找區間交集或間隔等。  |
| Iteration | 逐代 ta̍k-tāi | 疊代 | 迭代 | 重複執行某個過程或步驟，直到達成預期的結果或滿足特定條件。  |
| Johnson's algorithm | 強生演算法 kiông-sing ián-sǹg-huat | 強生演算法 | 约翰逊算法 | 一種用來在加權圖中計算所有點對最短路徑的演算法，適用於處理邊權可能為負值的情況。  |
| Josephus problem | 約瑟夫問題 Jio̍k-sik-hū būn-tê | 約瑟夫問題 | 约瑟夫斯难题 | 描述一群人按順序圍成一圈，每次刪除指定位置的人，直到只剩下最後一個人為止，要求找出最後存活的位置。  |
| Knapsack problems | kha·báng 問題 kha·báng-būn-tê | 背包問題 | 背包问题 | 在背包容量有限的情況下，選擇物品以達到最大總價值的問題，常見的有0/1背包問題和分數背包問題。  |
| Knuth-Morris-Pratt (KMP) algorithm | KMP 演算法 KMP ián-sǹg-huat | KMP 演算法 | KMP 算法 | 一種高效率的字串比對演算法，用於在主字串中搜尋子字串，避免不必要的重複比較。  |
| Kosaraju's algorithm | 科薩拉珠演算法 kho-sat-la-tsu ián-sǹg-huat | 科薩拉珠演算法 | 科萨拉朱算法 | 用來在有向圖中找到所有強連通元件的演算法，通過兩次深度優先搜尋來實現。  |
| Kruskal's algorithm | 克魯斯克爾演算法 khik-luh-suh-khik-nī ián-sǹg-huat | 克魯斯克爾演算法 | 克鲁斯克尔算法 | 一種用來在加權圖中找出最小生成樹的演算法，通過按邊的權重從小到大排序並逐步選擇邊來實現。  |
| Lagrange's four-square theorem | 四平方和定理 sì-pîng-hong-hô tīng-lí | 四平方和定理 | 拉格朗日四平方定理 | 每個自然數都可以表示為最多四個平方數的和。  |
| Layered traversal | 分層走訪 hun-tsân-tsáu-hóng | 分層走訪 | 分层遍历 | 從外到內逐層處理矩陣元素。  |
| Level order traversal | 分層走訪 hun-tsàn-tsáu-hóng | 層序走訪 | 层序遍历 | 一種樹的走訪方式，按層次從上到下、從左到右逐層訪問每個節點。  |
| Line sweep/sweep line algorithm | 掃描線 sàu-biâu-suànn | 掃描線 | 线扫描 | 藉由在平面上水平掃描或垂直掃描來解決幾何問題的方法，例如找出交點或計算區域。  |
| Linear search | 沿線搜揣 iân-suànn-tshiau-tshuē | 線性搜尋 | 线性搜索 | 一種逐一檢查每個元素以尋找目標值的搜尋方法。  |
| Linked list | 鍊仔列 liān-á-lia̍t | 鏈結串列 | 链接列表 | 由一系列節點組成，每個節點包含資料和指向下一個節點的指標。  |
| Logical reasoning | 邏輯推理 lô-tsi̍p-thui-lí | 邏輯推理 | 逻辑推理 | 運用數學邏輯來推導解決方案。  |
| Lowest common ancestor (LCA) | 上細相仝祖先 siōng-sè-sio-kāng-tsóo-sian | 最近共同祖先 | 最近公共祖先 | 在一棵二元樹中，給予兩個節點 p 和 q，它們的 LCA 是指同時位於 p 和 q 的祖先中，層級最高的那個節點。  |
| Manacher's algorithm | 馬拉車演算法 ma-la-tshia ián-sǹg-huat | 馬拉車演算法 | 马拉车算法 | 在 O(n) 時間內找出字串中最長迴文子串的高效演算法。  |
| Marking | 標記 piau-kì | 標記 | 标记 | 使用特殊值標記需要修改的元素。  |
| Math | 數學解法 sòo-ha̍k-kái-huat | 數學解法 | 数学解法 | 利用數學概念和技巧來解決計算、資料處理或數值分析的問題。  |
| Mathematical modeling | 數學造模 sòo-ha̍k-tsō-bôo | 數學建模 | 数学建模 | 將問題轉化為數學模型。  |
| Matrix | 矩陣 kí-tīn | 矩陣 | 矩阵 | 涉及對矩陣進行各種操作和處理，如搜尋、排序、變換或計算子矩陣。  |
| Max heap | 上大堆積 siōng-tuā-tui-tsik | 最大堆積 | 最大堆 | 每個節點的值都大於或等於其子節點的值，根節點具有最大的值。  |
| Meet in the middle | 中央相拄 tiong-ng-sio-tú | 中間相遇法 | 中间相遇 | 一種搜尋演算法策略，將問題分成兩部分，分別解決並合併結果，以減少計算複雜度。  |
| Merge sort | 合併排序 ha̍p-pìng-pâi-sī | 合併排序 | 合并排序 | 一種分治演算法，通過將陣列分成兩半，遞迴地排序每一半，然後合併已排序的子陣列來完成整體排序。  |
| Merging or splitting | 合併抑是分開 ha̍p-pìng ia̍h-sī hun-khui | 合併或分割 | 合并或拆分 | 在處理資料時，將多個部分合併為一個整體，或將一個整體分割成多個部分。  |
| Min heap | 上細堆積 siōng-sè-tui-tsik | 最小堆積 | 最小堆 | 每個節點的值都小於或等於其子節點的值，根節點具有最小的值。  |
| Minimum bottleneck spanning tree (MBST) | 上細關頭生湠樹 siōng-sè-kuan-thâu-senn-thuànn-tshiū | 最小瓶頸擴張樹 | 最小瓶颈生成树 | 一種擴張樹演算法，目的在找到使得所有邊的最大權重最小的擴張樹。  |
| Minimum spanning tree (MST) | 上細生湠樹 siōng-sè-senn-thuànn-tshiū | 最小生成樹 | 最小生成树 | 在加權圖中，找出一個連通子圖，使其包含所有節點且邊的總權重最小。  |
| Modular arithmetic | 模數算數 bôo-sòo-sǹg-siàu | 模數算數 | 模数运算 | 一種數學運算，將數字除以模數後，取餘數作為結果。  |
| Monotonic queue | 單調排陣 tan-tiāu-pâi-tīn | 單調佇列 | 单调队列 | 維護一個遞增或遞減的佇列來解決特定問題。  |
| Multiple pointers | 倍數指標 puē-sòo-tsí-piau | 多重指標 | 多重指针 | 在資料結構中使用多個指標來同時處理或追蹤不同的元素或位置。  |
| Neighbors check | 檢查厝邊 kiám-tsa-tshù-pinn | 鄰居檢查 | 邻居检查 | 在處理圖問題時，檢查一個元素的相鄰或鄰近元素的狀態或屬性。  |
| Node deletion | 節點刪除 tsiat-tiám-san-tû | 節點刪除 | 节点删除 | 在資料結構中移除某個節點及其相關連結的操作。  |
| Opposite direction pointers | 別向指標 pa̍t-hiòng-tsí-piau | 反向指標 | 反向指针 | 在資料結構中，兩個指標朝向相反方向或指向相對位置的元素。  |
| Optimization | 改良 kái-liông | 最佳化 | 优化 | 使用數學方法最佳化解決方案。  |
| Optimize space usage | 改良空間使用 kái-liông-khong-kan-sú-iōng | 最佳化空間的使用 | 优化空间利用率 | 盡可能在原地修改陣列，減少額外空間使用。  |
| Palindrome problems | 迴文問題 huê-bûn-būn-tê | 迴文問題 | 回文问题 | 判斷或處理字串、數字等是否順讀和反讀都相同的問題。  |
| Partially ordered set (Poset) | 偏序集合 phian-sī-tsi̍p-ha̍p | 偏序集合 | 偏序集 | 一種集合，其中的元素根據某種部分順序關係進行排列，但並不是所有元素都有明確的順序比較。  |
| Perfect Binary Tree (PBT) | 完美雙爿樹 uân-bí siang-pîng-tshiū | 完美二元樹 | 完美二叉树 | 一種二元樹，所有層次的節點都被完全填滿，且所有葉子節點都位於同一層。  |
| Permutation problems | 排列問題 pâi-lia̍t būn-tê | 排列問題 | 排列问题 | 在給定的元素集合中，找出所有可能的排列順序或組合方式。  |
| Point-to-point shortest path | 兩點上短路徑 nn̄g-tiám-siōng-té-lōo-kìng | 點對點最短路徑 | 点对点最短路径 | 在圖中找出兩個指定節點之間的最短路徑。  |
| Postorder traversal | 後序走訪 āu-sū-tsáu-hóng | 後序走訪 | 后序遍历 | 一種樹的走訪方式，先走訪左子樹，再走訪右子樹，最後訪問節點本身。  |
| Prefix sum | 頭前和 thâu-tsîng-hô | 前置和 | 前缀和 | 計算從數列開始到某個位置累積的和。  |
| Preorder traversal | 前序走訪 tsîng-sū-tsáu-hóng | 前序走訪 | 前序遍历 | 一種樹的走訪方式，先訪問節點本身，再走訪左子樹，最後走訪右子樹。  |
| Prim's algorithm | 普林演算法 puh-lîm-ián-sǹg-huat | 普林演算法 | 普林算法 | 用來在加權圖中找出最小生成樹的演算法，通過逐步擴展樹的邊來實現。  |
| Priority queue | 代先排陣 tāi-sing-pâi-tīn | 優先佇列 | 优先队列 | 一種資料結構，按照元素的優先級進行排序，允許快速地插入元素並取出具有最高或最低優先級的元素。  |
| Pruning | 修剪 siu-tsián | 剪枝 | 剪枝 | 在搜尋或最佳化的過程中，提早剪除不必要的分支或選項，以提高效率。  |
| Queue | 排陣 pâi-tīn | 佇列 | 队列 | Queue 是一種資料結構，按照先進先出（FIFO）的原則處理元素，即先加入的元素先被移除。  |
| Quick select/Hoare's selection algorithm | 緊氣選擇演算法/霍爾選擇演算法 kín-khuì-suán-ti̍k-ián-sǹg-huat/hoare-suán-ti̍k-ián-sǹg-huat | 快速選擇演算法/霍爾選擇演算法 | 快速选择算法/霍尔选择算法 | 在未排序的數列中高效地找到第 k 小的元素。  |
| Quick sort | 緊氣排序 kín-khuì-pâi-sī | 快速排序 | 快速排序 | 一種分治排序演算法，通過選擇一個基準元素將陣列分為兩部分，分別對每部分進行排序，然後合併結果來完成整體排序。  |
| Rabin-Karp algorithm | 拉賓-卡普演算法 la-pin-khah-puh ián-sǹg-huat | 拉賓-卡普演算法 | 拉宾-卡普算法 | 一種字串搜尋演算法，利用雜湊函數高效率的地在主字串中尋找子字串的所有出現位置。  |
| Radix sort | 基數排序 ki-sòo-pâi-sī | 基數排序 | 基数排序 | 一種非比較排序演算法，通過將資料按位數字進行排序，從最低位到最高位來完成排序。  |
| Randomized algorithm | 隨機演算法 suî-ki ián-sǹg-huat | 隨機化演算法 | 随机化算法 | 使用了隨機函數，且回傳值直接或者間接的影響了演算法的執行流程或執行結果。  |
| Range sum queries | 區間和查詢 khu-kan-hô-tshâ-sûn | 區間和查詢 | 范围总和查询 | 在一個數列中，對指定區間內元素的和進行查詢或計算。  |
| Recursion | 遞迴 tē-huê | 遞迴 | 递归 | 函數或程式會直接或間接地調用自身來解決問題。  |
| Regular expression | 正規表達式 tsìng-kui-piáu-ta̍t-sik | 正規表達式 | 正则表达式 | 用於描述和比對字串規則的強大工具和語法。  |
| Same direction pointers | 仝向指標 kāng-hiòng-tsí-piau | 同向指標 | 同向指针 | 在資料結構中，兩個或多個指標朝向相同方向或指向相同類型的元素。  |
| Scrolling array | 滾絞陣列 kún-ká-tīn-lia̍t | 滾動陣列 | 滚动数组 | 用於在固定大小的數列中維護滑動視窗的狀態，通常用於解決滑動視窗問題。  |
| Searching algorithms | 搜揣演算法 tshiau-tshuē ián-sǹg-huat | 搜尋演算法 | 搜索算法 | 在資料結構中尋找特定元素或資訊的方法。  |
| Segment tree | 線段樹 suànn-tuānn-tshiū | 線段樹 | 线段树 | 一種樹形資料結構，用於高效率地處理和查詢區間（範圍）內的資訊，如範圍和、範圍最小值等。  |
| Selection sort | 選擇排序 suán-ti̍k-pâi-sī | 選擇排序 | 选择排序 | 一種逐步排序演算法，通過反覆選擇未排序部分中的最小或最大元素，並將其放置於已排序部分的末尾來完成排序。  |
| Shell sort | 希爾排序 hi-nī-pâi-sī | 希爾排序 | 希尔排序 | 一種改進過的插入排序算法，它通過先比較間隔較大的元素，逐步減小間隔，來提高排序效率。  |
| Shortest path problems | 上短路徑問題 siōng-té-lōo-kìng-būn-tê | 最短路徑問題 | 最短路径问题 | 尋找圖中兩點間最短路徑的問題。  |
| Sieve of Eratosthenes | 篩仔法 thai-á-huat | 篩選法 | 筛分法 | 一種用來找出質數的算法，透過逐步排除合數來達到目標。  |
| Single source shortest path (SSSP) | 孤源上短路徑 koo-guân-siōng-té-lōo-kìng | 單源最短路徑 | 单源最短路径 | 在加權圖中，從一個特定起點到所有其他節點的最短路徑問題。  |
| Singly linked list | 單向鍊仔列 tan-hiànn-liān-á-lia̍t | 單向鏈結串列 | 单链表 | 一種資料結構，每個節點包含資料和指向下一個節點的指標，但沒有指向前一個節點的指標。  |
| Sliding window | 活動窗仔 ua̍h-tāng-thang-á | 滑動視窗 | 滑动窗口 | 用於在數列或資料中動態維持一個固定大小的視窗，以便高效率地處理或計算區間內的資訊。  |
| Sorting | 排序 pâi-sī | 排序 | 排序 | 將一組資料按照特定順序（例如遞增或遞減）進行排列的過程。  |
| Sorting algorithms | 排序演算法 pâi-sī ián-sǹg-huat | 排序演算法 | 排序算法 | 將資料中的元素按照指定順序（如從小到大）進行排列的方法。  |
| Stack | 堆疊 tui-thia̍p | 堆疊 | 堆 | 一種資料結構，按照後進先出（LIFO）的原則處理元素，即最後加入的元素最先被移除。  |
| State encoding | 狀態編碼 tsōng-thài-pian-bé | 狀態編碼 | 状态编码 | 使用位操作或特殊值來在有限的空間內編碼多個狀態。  |
| String | 串字 tshuàn-jī | 字串 | 字符串 | 一種資料類型，用於儲存和操作由字元組成的文字或字串。  |
| String matching | 串字比對 tshuàn-jī-pí-tuì | 字串比對 | 字符串匹配 | 在文字中尋找特定字串或規則的過程。  |
| Strongly connected components (SCC) | 強連結元件 kiông-liân-kiat-guân-kiānn | 強連通元件 | 强连通分量 | 在有向圖中，每個分量內的任意兩個節點都可以互相到達的最大節點集合。  |
| Subarray sum problems | 子陣列和問題 tsú-tīn-lia̍t-hô būn-tê | 子陣列和問題 | 子数组和问题 | 在數列中找出子數列的和，通常需要解決最大和、最小和或特定和等問題。  |
| Subset problems | 子集合問題 tsú-tsi̍p-ha̍p būn-tê | 子集問題 | 子集问题 | 在給定的元素集合中，找出所有可能的子集或滿足特定條件的子集。  |
| Tarjan's strongly connected components algorithm | 塔爾詹演算法 thah-nī-tsiam ián-sǹg-huat | 塔爾詹演算法 | 塔尔詹算法 | 用來在有向圖中找出所有強連通元件，即每個元件中的任意兩個節點都可以互相到達。  |
| Topological sort | 拓形排序 thok-hîng-pâi-sī | 拓撲排序 | 拓扑排序 | 對有向無環圖（DAG）進行排序，使得對於每一對有向邊 u ->v，節點 u 在排序中位於節點 v 之前。  |
| Totally ordered set | 全序集合 tsuân-sī-tsi̍p-ha̍p | 全序集合 | 全序集 | 一種集合，其中的元素可以根據某種完全順序關係進行比較，每對元素都有確定的順序。  |
| Transpose and reverse | 對換佮反轉 tuì-uānn kah huán-tsuán | 轉置和反轉 | 转置和反转 | 將矩陣進行轉置（行列互換）後，再將其內容反轉（如每行或每列反向排列）的操作。  |
| Travelling salesman problem (TSP) | 出外販仔的問題 tshut-guā huàn-á ê būn-tê | 旅行商問題 | 旅行商问题 | 在給定一組城市和城市間的距離，找出一條最短的閉環路徑，使得每個城市僅被訪問一次，並回到起點。  |
| Treap (tree + heap) | 樹堆積 tshiū-tui-tsik | 樹堆積 | 树堆 | 一種資料結構，結合了二元搜尋樹和最小堆積的特性，用於維護元素的排序和優先級。  |
| Tree | 樹 tshiū | 樹 | 树 | 一種層級資料結構，由節點組成，每個節點可以有零個或多個子節點，並且沒有循環，通常用於表示階層關係或組織結構。  |
| Trie | 辭典樹 sû-tián-tshiū | 字點樹 | 字典树 | 一種樹形資料結構，專門用於儲存和查詢字串，能夠有效地處理字典中單字的前置比對。  |
| Two pointers technique | 雙指標法 siang-tsí-piau-huat | 雙指標法 | 双指针法 | 用兩個指標在資料結構中進行掃描或比較，以解決問題或提高效率。  |
| Two-pass approach | 走訪兩改 tsáu-hóng-nn̄g-kái | 兩次走訪 | 两遍方法 | 對資料進行兩次走訪來完成某項任務或計算，通常用於解決需要分兩步處理的問題。  |
| Undirected graph | 無向圖 bô-hiòng-tôo | 無向圖 | 无向图 | 在圖中，邊沒有方向，任意兩個節點之間的連接是雙向的。  |
| Vector | 向量 hiòng-liōng | 向量 | 向量 | 動態陣列資料結構，可以自動調整大小，並提供快速的隨機存取和有效率的插入或刪除操作。  |
